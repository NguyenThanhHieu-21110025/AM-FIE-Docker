import React, { useState, useEffect, useRef } from "react";
import ChatBox from "../../components/ChatBox";
import ChatInput from "../../components/ChatInput";
import ChatSidebar from "../../components/ChatSideBar";
import "../../../css/Chatbot.css";
import { Chat, ChatSession } from "../../interfaces/Chat";

// API base URL
const API_BASE_URL = "http://localhost:8080";

// Helper ƒë·ªÉ ƒë·∫£m b·∫£o Chat object c√≥ ƒë·ªãnh d·∫°ng ƒë√∫ng
const formatChat = (msg: any): Chat => {
  return {
    id: String(msg.id || msg._id || `msg-${Date.now()}`),
    sessionId: msg.sessionId ? String(msg.sessionId) : undefined,
    role: (msg.role || (msg.userInput ? "user" : "assistant")) as
      | "user"
      | "assistant"
      | "system",
    content: String(
      msg.content || msg.text || msg.userInput || msg.botResponse || ""
    ),
    timestamp: new Date(msg.timestamp || Date.now()),
    metadata: msg.metadata || {},
    userInput:
      msg.role === "user" || msg.userInput
        ? String(msg.content || msg.userInput || "")
        : "",
    botResponse:
      msg.role === "assistant" || msg.botResponse
        ? String(msg.content || msg.botResponse || "")
        : "",
    sender: msg.role === "user" || msg.userInput ? "user" : "bot",
    text: String(
      msg.content || msg.text || msg.userInput || msg.botResponse || ""
    ),
  };
};

// Helper ƒë·ªÉ ƒë·∫£m b·∫£o ChatSession object c√≥ ƒë·ªãnh d·∫°ng ƒë√∫ng
const formatChatSession = (session: any): ChatSession => {
  return {
    id: String(session._id || session.id),
    title: String(session.title || "Cu·ªôc tr√≤ chuy·ªán m·ªõi"),
    userId: session.userId ? String(session.userId) : undefined,
    isActive: Boolean(session.isActive !== false),
    createdAt: new Date(session.createdAt || Date.now()),
    updatedAt: new Date(session.updatedAt || Date.now()),
    messages: Array.isArray(session.messages)
      ? session.messages.map((msg: any) => formatChat(msg))
      : [],
    metadata: session.metadata || {},
  };
};

const ChatbotPage: React.FC = () => {
  const [sessions, setSessions] = useState<ChatSession[]>([]);
  const [activeSessionId, setActiveSessionId] = useState<string>("");
  const [loading, setLoading] = useState<boolean>(false);
  const [isInitialized, setIsInitialized] = useState<boolean>(false);

  // L·∫•y userId t·ª´ localStorage (gi·∫£ s·ª≠ ƒë√£ ƒëƒÉng nh·∫≠p) ho·∫∑c null n·∫øu kh√¥ng ƒëƒÉng nh·∫≠p
  const userId = localStorage.getItem("userId");
  console.log("Current userId from localStorage:", userId);
  const chatboxRef = useRef<HTMLDivElement>(null);

  // Kh·ªüi t·∫°o v·ªõi m·ªôt session m·∫∑c ƒë·ªãnh ho·∫∑c t·∫£i t·ª´ storage
  useEffect(() => {
    if (!isInitialized) {
      loadSessions();
      setIsInitialized(true);
    }
  }, [isInitialized]);

  // Auto-scroll khi c√≥ tin nh·∫Øn m·ªõi
  useEffect(() => {
    if (chatboxRef.current) {
      chatboxRef.current.scrollTop = chatboxRef.current.scrollHeight;
    }
  }, [sessions, activeSessionId]);

  // T·∫£i danh s√°ch sessions
  const loadSessions = async () => {
    try {
      // Th·ª≠ t·∫£i t·ª´ localStorage tr∆∞·ªõc
      const savedSessions = localStorage.getItem("chatSessions");
      if (savedSessions) {
        try {
          const parsedSessions = JSON.parse(savedSessions);
          // ƒê·∫£m b·∫£o m·∫£ng c√≥ ƒë·ªãnh d·∫°ng ch√≠nh x√°c
          const formattedSessions = parsedSessions.map((session: any) =>
            formatChatSession(session)
          );
          setSessions(formattedSessions);
          setActiveSessionId(formattedSessions[0]?.id || "");
          return;
        } catch (parseError) {
          console.error("Error parsing saved sessions:", parseError);
          localStorage.removeItem("chatSessions");
        }
      }

      // N·∫øu c√≥ userId, t·∫£i sessions t·ª´ API
      if (userId) {
        try {
          const response = await fetch(
            `${API_BASE_URL}/api/chat/sessions/${userId}`
          );
          if (response.ok) {
            const sessionsData = await response.json();

            if (sessionsData && sessionsData.length > 0) {
              // Chuy·ªÉn ƒë·ªïi ƒë·ªãnh d·∫°ng sessions ƒë·ªÉ ph√π h·ª£p v·ªõi giao di·ªán
              const formattedSessions = sessionsData.map((session: any) =>
                formatChatSession(session)
              );

              setSessions(formattedSessions);
              setActiveSessionId(formattedSessions[0].id);
              saveSessions(formattedSessions);
              return;
            }
          }
        } catch (apiError) {
          console.error("Error loading sessions from API:", apiError);
        }
      } else {
        // N·∫øu kh√¥ng c√≥ userId, th·ª≠ t·∫£i history theo c√°ch c≈©
        try {
          const response = await fetch(`${API_BASE_URL}/api/chat/history`);
          if (response.ok) {
            const messages = await response.json();

            if (messages && messages.length > 0) {
              // Nh√≥m tin nh·∫Øn theo sessionId
              const sessionMap = new Map<string, ChatSession>();

              messages.forEach((msg: any) => {
                const sessionId =
                  msg.sessionId ||
                  `session-${new Date(msg.timestamp).toLocaleDateString()}`;

                if (!sessionMap.has(sessionId)) {
                  sessionMap.set(
                    sessionId,
                    formatChatSession({
                      id: sessionId,
                      title:
                        msg.metadata?.sessionTitle ||
                        `Cu·ªôc tr√≤ chuy·ªán ${new Date(
                          msg.timestamp
                        ).toLocaleDateString()}`,
                      isActive: true,
                      createdAt: new Date(msg.timestamp),
                      updatedAt: new Date(msg.timestamp),
                      messages: [],
                    })
                  );
                }

                const formattedMsg = formatChat({
                  id: msg._id,
                  sessionId: sessionId,
                  role: msg.userInput ? "user" : "assistant",
                  content: msg.userInput || msg.botResponse,
                  timestamp: msg.timestamp,
                  metadata: msg.metadata,
                });

                const session = sessionMap.get(sessionId);
                if (session && session.messages) {
                  session.messages.push(formattedMsg);
                }
              });

              const newSessions = Array.from(sessionMap.values()).sort(
                (a, b) =>
                  new Date(b.updatedAt).getTime() -
                  new Date(a.updatedAt).getTime()
              );

              if (newSessions.length > 0) {
                setSessions(newSessions);
                setActiveSessionId(newSessions[0].id);
                saveSessions(newSessions);
                return;
              }
            }
          }
        } catch (historyError) {
          console.error("Error loading chat history:", historyError);
        }
      }

      // N·∫øu kh√¥ng c√≥ d·ªØ li·ªáu, t·∫°o session m·ªõi
      createNewSession();
    } catch (error) {
      console.error("Error loading chat sessions:", error);
      createNewSession();
    }
  };

  const saveSessions = (updatedSessions: ChatSession[]) => {
    try {
      localStorage.setItem("chatSessions", JSON.stringify(updatedSessions));
    } catch (error) {
      console.error("Error saving sessions to localStorage:", error);
    }
  };

  // T·∫°o phi√™n tr√≤ chuy·ªán m·ªõi
  const createNewSession = async (): Promise<ChatSession> => {
    try {
      let newSession: ChatSession;

      if (userId) {
        try {
          // T·∫°o session m·ªõi qua API
          const response = await fetch(`${API_BASE_URL}/api/chat/sessions`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ userId, title: "Cu·ªôc tr√≤ chuy·ªán m·ªõi" }),
          });

          if (response.ok) {
            const sessionData = await response.json();
            newSession = formatChatSession(sessionData);
          } else {
            throw new Error("Kh√¥ng th·ªÉ t·∫°o phi√™n chat m·ªõi");
          }
        } catch (apiError) {
          console.error("Error creating session via API:", apiError);
          // Fallback to local session if API call fails
          newSession = formatChatSession({
            id: `local-session-${Date.now()}`,
            title: `Cu·ªôc tr√≤ chuy·ªán m·ªõi`,
            isActive: true,
            createdAt: new Date(),
            updatedAt: new Date(),
            messages: [],
          });
        }
      } else {
        // T·∫°o session c·ª•c b·ªô
        newSession = formatChatSession({
          id: `local-session-${Date.now()}`,
          title: `Cu·ªôc tr√≤ chuy·ªán m·ªõi`,
          isActive: true,
          createdAt: new Date(),
          updatedAt: new Date(),
          messages: [],
        });
      }

      // Th√™m tin nh·∫Øn ch√†o m·ª´ng t·ª´ bot
      const welcomeMessage: Chat = formatChat({
        id: `msg-welcome-${Date.now()}`,
        sessionId: newSession.id,
        role: "assistant",
        content:
          "üëã Xin ch√†o! T√¥i l√† Tr·ª£ l√Ω Qu·∫£n l√Ω T√†i s·∫£n c·ªßa Tr∆∞·ªùng ƒê·∫°i h·ªçc S∆∞ ph·∫°m K·ªπ thu·∫≠t TP.HCM (HCMUTE).\n\nT√¥i c√≥ th·ªÉ gi√∫p b·∫°n:\n‚Ä¢ Tra c·ª©u th√¥ng tin v·ªÅ t√†i s·∫£n trong tr∆∞·ªùng\n‚Ä¢ T√¨m ki·∫øm t√†i s·∫£n theo ph√≤ng, m√£ s·ªë, nƒÉm s·ª≠ d·ª•ng\n‚Ä¢ Cung c·∫•p th√¥ng tin v·ªÅ gi√° tr·ªã, t√¨nh tr·∫°ng t√†i s·∫£n\n‚Ä¢ Tr·∫£ l·ªùi c√°c c√¢u h·ªèi v·ªÅ qu·∫£n l√Ω t√†i s·∫£n\n\nH√£y ƒë·∫∑t c√¢u h·ªèi ƒë·ªÉ t√¥i c√≥ th·ªÉ h·ªó tr·ª£ b·∫°n!",
        timestamp: new Date(),
      });

      // Th√™m tin nh·∫Øn ch√†o m·ª´ng v√†o session
      newSession.messages = [welcomeMessage];

      const updatedSessions: ChatSession[] = [newSession, ...sessions];
      setSessions(updatedSessions);
      setActiveSessionId(newSession.id);
      saveSessions(updatedSessions);

      return newSession;
    } catch (error) {
      console.error("Error creating new session:", error);
      // Fallback t·∫°o local session
      const newSession = formatChatSession({
        id: `local-session-${Date.now()}`,
        title: `Cu·ªôc tr√≤ chuy·ªán m·ªõi`,
        isActive: true,
        createdAt: new Date(),
        updatedAt: new Date(),
        messages: [],
      });

      // Th√™m tin nh·∫Øn ch√†o m·ª´ng t·ª´ bot
      const welcomeMessage: Chat = formatChat({
        id: `msg-welcome-${Date.now()}`,
        sessionId: newSession.id,
        role: "assistant",
        content:
          "üëã Xin ch√†o! T√¥i l√† Tr·ª£ l√Ω Qu·∫£n l√Ω T√†i s·∫£n c·ªßa Tr∆∞·ªùng ƒê·∫°i h·ªçc S∆∞ ph·∫°m K·ªπ thu·∫≠t TP.HCM (HCMUTE).\n\nT√¥i c√≥ th·ªÉ gi√∫p b·∫°n:\n‚Ä¢ Tra c·ª©u th√¥ng tin v·ªÅ t√†i s·∫£n trong tr∆∞·ªùng\n‚Ä¢ T√¨m ki·∫øm t√†i s·∫£n theo ph√≤ng, m√£ s·ªë, nƒÉm s·ª≠ d·ª•ng\n‚Ä¢ Cung c·∫•p th√¥ng tin v·ªÅ gi√° tr·ªã, t√¨nh tr·∫°ng t√†i s·∫£n\n‚Ä¢ Tr·∫£ l·ªùi c√°c c√¢u h·ªèi v·ªÅ qu·∫£n l√Ω t√†i s·∫£n\n\nH√£y ƒë·∫∑t c√¢u h·ªèi ƒë·ªÉ t√¥i c√≥ th·ªÉ h·ªó tr·ª£ b·∫°n!",
        timestamp: new Date(),
      });

      // Th√™m tin nh·∫Øn ch√†o m·ª´ng v√†o session
      newSession.messages = [welcomeMessage];

      const updatedSessions: ChatSession[] = [newSession, ...sessions];
      setSessions(updatedSessions);
      setActiveSessionId(newSession.id);
      saveSessions(updatedSessions);

      return newSession;
    }
  };

  const handleSessionSelect = (sessionId: string) => {
    setActiveSessionId(sessionId);
  };

  const handleDeleteSession = async (sessionId: string) => {
    // N·∫øu x√≥a session ƒëang active, chuy·ªÉn sang session kh√°c tr∆∞·ªõc
    if (sessionId === activeSessionId && sessions.length > 1) {
      const newActiveIndex =
        sessions.findIndex((s) => s.id === sessionId) === 0 ? 1 : 0;
      setActiveSessionId(sessions[newActiveIndex].id);
    } else if (sessionId === activeSessionId) {
      // N·∫øu l√† session active cu·ªëi c√πng, reset activeSessionId
      setActiveSessionId("");
    }

    try {
      if (!sessionId.startsWith("local-") && userId) {
        // X√≥a session t·ª´ API
        await fetch(`${API_BASE_URL}/api/chat/sessions/${sessionId}`, {
          method: "DELETE",
        });
      }
    } catch (error) {
      console.error("Error deleting session:", error);
    }

    // Lu√¥n c·∫≠p nh·∫≠t UI
    const updatedSessions = sessions.filter((s) => s.id !== sessionId);
    setSessions(updatedSessions);
    saveSessions(updatedSessions);
  };

  const updateSessionTitle = (sessionId: string, firstMessage: string) => {
    // T·∫°o ti√™u ƒë·ªÅ t·ª´ tin nh·∫Øn ƒë·∫ßu ti√™n (gi·ªõi h·∫°n 30 k√Ω t·ª±)
    const title =
      firstMessage.length > 30
        ? `${firstMessage.substring(0, 30)}...`
        : firstMessage;

    const updatedSessions: ChatSession[] = sessions.map((session) =>
      session.id === sessionId ? { ...session, title } : session
    );

    setSessions(updatedSessions);
    saveSessions(updatedSessions);
  };

  const handleSendMessage = async (userInput: string) => {
    if (!userInput.trim()) return;

    // T√¨m session ƒëang active
    let sessionIndex = sessions.findIndex((s) => s.id === activeSessionId);
    let currentSession: ChatSession;

    // N·∫øu kh√¥ng c√≥ session active, t·∫°o m·ªõi
    if (sessionIndex === -1) {
      currentSession = await createNewSession();
      sessionIndex = 0;
    } else {
      currentSession = { ...sessions[sessionIndex] };
    }

    // Th√™m tin nh·∫Øn ng∆∞·ªùi d√πng v√†o chat
    const userMessage: Chat = formatChat({
      id: `msg-${Date.now()}-user`,
      sessionId: activeSessionId,
      role: "user",
      content: userInput,
      timestamp: new Date(),
    });

    // X√°c ƒë·ªãnh messages, ƒë·∫£m b·∫£o kh√¥ng b·ªã null/undefined
    const existingMessages = currentSession.messages || [];

    // C·∫≠p nh·∫≠t session v·ªõi tin nh·∫Øn m·ªõi
    const updatedSession = {
      ...currentSession,
      messages: [...existingMessages, userMessage],
      updatedAt: new Date(),
    };

    // N·∫øu l√† tin nh·∫Øn ƒë·∫ßu ti√™n, c·∫≠p nh·∫≠t ti√™u ƒë·ªÅ session
    if (existingMessages.length === 0) {
      updateSessionTitle(activeSessionId, userInput);
    }

    // C·∫≠p nh·∫≠t state
    const updatedSessions: ChatSession[] = [...sessions];
    updatedSessions[sessionIndex] = updatedSession;
    setSessions(updatedSessions);
    saveSessions(updatedSessions);

    setLoading(true);

    try {
      // Ghi l·∫°i th√¥ng tin session hi·ªán t·∫°i ƒë·ªÉ x·ª≠ l√Ω tr∆∞·ªùng h·ª£p session thay ƒë·ªïi
      const currentActiveSessionId = activeSessionId;
      const isLocalSession = currentActiveSessionId.startsWith("local-");

      // N·∫øu sessionId b·∫Øt ƒë·∫ßu b·∫±ng 'local-', g·ª≠i null ƒë·ªÉ backend t·∫°o m·ªõi
      const sessionIdToSend = isLocalSession ? null : currentActiveSessionId;

      const response = await fetch(`${API_BASE_URL}/api/chat/send`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          message: userInput,
          sessionId: sessionIdToSend,
          userId,
        }),
      });

      if (!response.ok) {
        throw new Error(`Server responded with status: ${response.status}`);
      }

      const data = await response.json();

      // C·ªù ƒë√°nh d·∫•u l√† ƒë√£ x·ª≠ l√Ω ph·∫£n h·ªìi t·ª´ bot hay ch∆∞a
      let botResponseHandled = false;

      // *** X·ª¨ L√ù SESSION LOCAL ƒê∆Ø·ª¢C THAY TH·∫æ B·∫∞NG SESSION SERVER ***
      if (data.sessionId && isLocalSession) {
        try {
          // L·∫•y session chi ti·∫øt t·ª´ server
          const sessionResponse = await fetch(
            `${API_BASE_URL}/api/chat/sessions/detail/${data.sessionId}`
          );
          if (sessionResponse.ok) {
            const newSessionData = await sessionResponse.json();

            // Ki·ªÉm tra xem tin nh·∫Øn ng∆∞·ªùi d√πng v·ª´a g·ª≠i ƒë√£ c√≥ trong d·ªØ li·ªáu t·ª´ server ch∆∞a
            const serverMessages = newSessionData.messages || [];
            const userMessageExists = serverMessages.some(
              (msg: any) => msg.role === "user" && msg.content === userInput
            );

            // Chu·∫©n b·ªã tin nh·∫Øn ƒë·ªÉ th√™m v√†o
            const messagesToKeep: Chat[] = [];

            // N·∫øu server ƒë√£ c√≥ tin nh·∫Øn ng∆∞·ªùi d√πng, s·ª≠ d·ª•ng messages t·ª´ server
            if (userMessageExists) {
              messagesToKeep.push(
                ...serverMessages.map((msg: any) => formatChat(msg))
              );
            } else {
              // N·∫øu kh√¥ng, th√™m tin nh·∫Øn ng∆∞·ªùi d√πng hi·ªán t·∫°i v√†o messages t·ª´ server
              messagesToKeep.push(
                ...serverMessages.map((msg: any) => formatChat(msg)),
                userMessage
              );
            }

            // Ki·ªÉm tra xem tin nh·∫Øn bot ƒë√£ c√≥ trong d·ªØ li·ªáu server ch∆∞a
            const botMessageExists = serverMessages.some(
              (msg: any) =>
                msg.role === "assistant" &&
                new Date(msg.timestamp).getTime() > new Date().getTime() - 10000 // Trong 10 gi√¢y qua
            );

            // N·∫øu ch∆∞a c√≥ tin nh·∫Øn bot t·ª´ server, th√™m v√†o
            if (!botMessageExists) {
              const botMessage: Chat = formatChat({
                id: `msg-${Date.now()}-bot`,
                sessionId: data.sessionId,
                role: "assistant",
                content: data.response,
                timestamp: new Date(),
              });
              messagesToKeep.push(botMessage);
            }

            // Chuy·ªÉn ƒë·ªïi session local th√†nh session t·ª´ server
            const serverSession = formatChatSession({
              ...newSessionData,
              messages: messagesToKeep,
            });

            // C·∫≠p nh·∫≠t danh s√°ch sessions
            const updatedSessionsWithNewId = sessions.map((s) =>
              s.id === currentActiveSessionId ? serverSession : s
            );

            setSessions(updatedSessionsWithNewId);
            setActiveSessionId(data.sessionId);
            saveSessions(updatedSessionsWithNewId);

            // ƒê√°nh d·∫•u l√† ƒë√£ x·ª≠ l√Ω xong
            botResponseHandled = true;
          }
        } catch (error) {
          console.error("Error fetching session details:", error);
          // N·∫øu c√≥ l·ªói, v·∫´n ti·∫øp t·ª•c x·ª≠ l√Ω b√¨nh th∆∞·ªùng
        }
      }

      // *** X·ª¨ L√ù B√åNH TH∆Ø·ªúNG KHI ƒê√É C√ì SESSION SERVER (ch·ªâ khi ch∆∞a x·ª≠ l√Ω ·ªü tr√™n) ***
      if (!botResponseHandled) {
        try {
          // T·∫£i l·∫°i session m·ªõi nh·∫•t t·ª´ server
          const sessionResponse = await fetch(
            `${API_BASE_URL}/api/chat/sessions/detail/${
              data.sessionId || currentActiveSessionId
            }`
          );

          if (sessionResponse.ok) {
            const updatedSessionData = await sessionResponse.json();
            const serverSession = formatChatSession(updatedSessionData);

            // C·∫≠p nh·∫≠t session trong danh s√°ch
            const updatedSessions = sessions.map((s) =>
              s.id === (data.sessionId || currentActiveSessionId)
                ? serverSession
                : s
            );

            setSessions(updatedSessions);
            saveSessions(updatedSessions);
          } else {
            // Fallback n·∫øu kh√¥ng l·∫•y ƒë∆∞·ª£c session: ch·ªâ th√™m tin nh·∫Øn bot v√†o session hi·ªán t·∫°i
            const botMessage: Chat = formatChat({
              id: `msg-${Date.now()}-bot`,
              sessionId: data.sessionId || currentActiveSessionId,
              role: "assistant",
              content: data.response,
              timestamp: new Date(),
            });

            // T√¨m session trong danh s√°ch hi·ªán t·∫°i
            const updatedSessionIndex = sessions.findIndex(
              (s) => s.id === (data.sessionId || currentActiveSessionId)
            );

            if (updatedSessionIndex !== -1) {
              const updatedSessions = [...sessions];
              const sessionToUpdate = {
                ...updatedSessions[updatedSessionIndex],
              };
              const currentMessages = sessionToUpdate.messages || [];

              // Th√™m tin nh·∫Øn bot v√†o session
              sessionToUpdate.messages = [...currentMessages, botMessage];
              sessionToUpdate.updatedAt = new Date();

              updatedSessions[updatedSessionIndex] = sessionToUpdate;
              setSessions(updatedSessions);
              saveSessions(updatedSessions);
            }
          }
        } catch (error) {
          console.error("Error fetching updated session:", error);

          // Th√™m ph·∫£n h·ªìi c·ªßa bot v√†o chat (ph∆∞∆°ng ph√°p c≈©)
          const botMessage: Chat = formatChat({
            id: `msg-${Date.now()}-bot`,
            sessionId: data.sessionId || currentActiveSessionId,
            role: "assistant",
            content: data.response,
            timestamp: new Date(),
          });

          // Logic c≈©
          const updatedSessionIndex = sessions.findIndex(
            (s) => s.id === (data.sessionId || currentActiveSessionId)
          );

          if (updatedSessionIndex !== -1) {
            const updatedSessions = [...sessions];
            const sessionToUpdate = { ...updatedSessions[updatedSessionIndex] };
            const currentMessages = sessionToUpdate.messages || [];

            sessionToUpdate.messages = [...currentMessages, botMessage];
            sessionToUpdate.updatedAt = new Date();

            updatedSessions[updatedSessionIndex] = sessionToUpdate;
            setSessions(updatedSessions);
            saveSessions(updatedSessions);
          }
        }
      }
    } catch (error) {
      console.error("Error sending message:", error);
      // Hi·ªÉn th·ªã l·ªói d∆∞·ªõi d·∫°ng tin nh·∫Øn h·ªá th·ªëng
      const sessionIndex = sessions.findIndex((s) => s.id === activeSessionId);
      if (sessionIndex !== -1) {
        const errorMessage = formatChat({
          id: `msg-${Date.now()}-system`,
          sessionId: activeSessionId,
          role: "system",
          content: "L·ªói k·∫øt n·ªëi: Kh√¥ng th·ªÉ nh·∫≠n ph·∫£n h·ªìi t·ª´ tr·ª£ l√Ω.",
          timestamp: new Date(),
        });

        const updatedSessions = [...sessions];
        const updatedSession = { ...updatedSessions[sessionIndex] };
        updatedSession.messages = [
          ...(updatedSession.messages || []),
          errorMessage,
        ];

        updatedSessions[sessionIndex] = updatedSession;
        setSessions(updatedSessions);
        saveSessions(updatedSessions);
      }
    } finally {
      setLoading(false);
    }
  };

  // L·∫•y tin nh·∫Øn c·ªßa session ƒëang active
  const activeSessionMessages =
    sessions.find((s) => s.id === activeSessionId)?.messages || [];

  return (
    <div className="page-wrapper">
      <div className="chatbot-page">
        <div className="chatbot-container">
          <ChatSidebar
            sessions={sessions}
            activeSessionId={activeSessionId}
            onSessionSelect={handleSessionSelect}
            onNewSession={createNewSession}
            onDeleteSession={handleDeleteSession}
          />
          <div className="chat-main">
            <div className="chat-header">
              <h2>
                {sessions.length > 0
                  ? sessions.find((s) => s.id === activeSessionId)?.title ||
                    "Tr√≤ chuy·ªán m·ªõi"
                  : "Kh√¥ng c√≥ cu·ªôc tr√≤ chuy·ªán"}
              </h2>
            </div>
            <div ref={chatboxRef} className="chatbox-container">
              {sessions.length > 0 ? (
                <ChatBox messages={activeSessionMessages} loading={loading} />
              ) : (
                <div className="empty-state">
                  <p>Kh√¥ng c√≥ cu·ªôc tr√≤ chuy·ªán n√†o</p>
                  <p>Vui l√≤ng t·∫°o cu·ªôc tr√≤ chuy·ªán m·ªõi ƒë·ªÉ b·∫Øt ƒë·∫ßu</p>
                </div>
              )}
            </div>
            <ChatInput
              onSendMessage={handleSendMessage}
              disabled={loading || sessions.length === 0}
            />
          </div>
        </div>
      </div>
    </div>
  );
};

export default ChatbotPage;
